--- virtualenv-1.8.4/virtualenv.py.orig	2012-11-25 18:11:26.000000000 +0100
+++ virtualenv-1.8.4/virtualenv.py	2013-01-11 18:31:34.212018758 +0100
@@ -72,7 +72,11 @@
                     'fnmatch', 'locale', 'encodings', 'codecs',
                     'stat', 'UserDict', 'readline', 'copy_reg', 'types',
                     're', 'sre', 'sre_parse', 'sre_constants', 'sre_compile',
-                    'zlib']
+                    'zlib', 'time', 'cStringIO', 'md5', '_hashlib', '_struct', 'bz2',
+                    '_collections', 'operator', 'itertools', 'math', 'binascii', 
+                    '_random', '_io', '_functools', 'array', '_socket', '_ssl', 'select',
+                    'fcntl', 'cPickle', 'datetime', 'syslog', '_sqlite3', 'unicodedata',
+                    'parser', 'simplejson', 'multiprocessing', '_multiprocessing']
 
 REQUIRED_FILES = ['lib-dynload', 'config']
 
@@ -1118,18 +1122,8 @@
         inc_dir = join(home_dir, 'include')
         bin_dir = join(home_dir, 'bin')
     elif not is_win:
-        lib_dir = join(home_dir, 'lib', py_version)
-        multiarch_exec = '/usr/bin/multiarch-platform'
-        if is_executable_file(multiarch_exec):
-            # In Mageia (2) and Mandriva distros the include dir must be like:
-            # virtualenv/include/multiarch-x86_64-linux/python2.7
-            # instead of being virtualenv/include/python2.7
-            p = subprocess.Popen(multiarch_exec, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-            stdout, stderr = p.communicate()
-            # stdout.strip is needed to remove newline character
-            inc_dir = join(home_dir, 'include', stdout.strip(), py_version + abiflags)
-        else:
-            inc_dir = join(home_dir, 'include', py_version + abiflags)
+        lib_dir = join(home_dir, sys.lib, py_version)
+        inc_dir = join(home_dir, 'include', py_version + abiflags)
         bin_dir = join(home_dir, 'bin')
     return home_dir, lib_dir, inc_dir, bin_dir
 
@@ -1234,7 +1228,6 @@
     else:
         prefix = sys.prefix
     mkdir(lib_dir)
-    fix_lib64(lib_dir)
     stdlib_dirs = [os.path.dirname(os.__file__)]
     if is_win:
         stdlib_dirs.append(join(os.path.dirname(stdlib_dirs[0]), 'DLLs'))
@@ -1267,6 +1260,15 @@
         site_filename = site_filename.replace('$py.class', '.py')
     site_filename_dst = change_prefix(site_filename, home_dir)
     site_dir = os.path.dirname(site_filename_dst)
+    # PLD fix
+    try:
+        os.symlink(
+            make_relative_path(os.path.join(site_dir, 'site-packages'),
+		    os.path.join(lib_dir, 'site-packages')),
+	    os.path.join(site_dir, 'site-packages')
+        )
+    except (OSError, NotImplementedError):
+        logger.info('Symlinking site-packages failed.')
     writefile(site_filename_dst, SITE_PY)
     writefile(join(site_dir, 'orig-prefix.txt'), prefix)
     site_packages_filename = join(site_dir, 'no-global-site-packages.txt')
@@ -1304,7 +1306,7 @@
         elif is_jython:
             exec_dir = join(sys.exec_prefix, 'Lib')
         else:
-            exec_dir = join(sys.exec_prefix, 'lib', py_version)
+            exec_dir = join(sys.exec_prefix, sys.lib, py_version)
         for fn in os.listdir(exec_dir):
             copyfile(join(exec_dir, fn), join(lib_dir, fn))
 
@@ -1616,27 +1618,6 @@
                     os.symlink(os.path.abspath(os.path.join(home_dir, subdir_name)), \
                                                             os.path.join(local_path, subdir_name))
 
-def fix_lib64(lib_dir):
-    """
-    Some platforms (particularly Gentoo on x64) put things in lib64/pythonX.Y
-    instead of lib/pythonX.Y.  If this is such a platform we'll just create a
-    symlink so lib64 points to lib
-    """
-    if [p for p in distutils.sysconfig.get_config_vars().values()
-        if isinstance(p, basestring) and 'lib64' in p]:
-        logger.debug('This system uses lib64; symlinking lib64 to lib')
-        assert os.path.basename(lib_dir) == 'python%s' % sys.version[:3], (
-            "Unexpected python lib dir: %r" % lib_dir)
-        lib_parent = os.path.dirname(lib_dir)
-        top_level = os.path.dirname(lib_parent)
-        lib_dir = os.path.join(top_level, 'lib')
-        lib64_link = os.path.join(top_level, 'lib64')
-        assert os.path.basename(lib_parent) == 'lib', (
-            "Unexpected parent dir: %r" % lib_parent)
-        if os.path.lexists(lib64_link):
-            return
-        os.symlink('lib', lib64_link)
-
 def resolve_interpreter(exe):
     """
     If the executable given isn't an absolute path, search $PATH for the interpreter
--- virtualenv-1.8.4/virtualenv_support/site.py.orig	2013-01-11 17:58:03.708727329 +0100
+++ virtualenv-1.8.4/virtualenv_support/site.py	2013-01-11 18:39:25.132008943 +0100
@@ -226,42 +226,25 @@
                                 os.path.join(prefix, "Extras", "lib", "python")]
 
                 else: # any other Python distros on OSX work this way
-                    sitedirs = [os.path.join(prefix, "lib",
+                    sitedirs = [os.path.join(prefix, sys.lib,
                                              "python" + sys.version[:3], "site-packages")]
 
             elif os.sep == '/':
                 sitedirs = [os.path.join(prefix,
-                                         "lib",
+                                         sys.lib,
                                          "python" + sys.version[:3],
                                          "site-packages"),
-                            os.path.join(prefix, "lib", "site-python"),
+                            os.path.join(prefix, sys.lib, "site-python"),
                             os.path.join(prefix, "python" + sys.version[:3], "lib-dynload")]
-                lib64_dir = os.path.join(prefix, "lib64", "python" + sys.version[:3], "site-packages")
-                if (os.path.exists(lib64_dir) and
-                    os.path.realpath(lib64_dir) not in [os.path.realpath(p) for p in sitedirs]):
-                    if _is_64bit:
-                        sitedirs.insert(0, lib64_dir)
-                    else:
-                        sitedirs.append(lib64_dir)
                 try:
                     # sys.getobjects only available in --with-pydebug build
                     sys.getobjects
                     sitedirs.insert(0, os.path.join(sitedirs[0], 'debug'))
                 except AttributeError:
                     pass
-                # Debian-specific dist-packages directories:
-                if sys.version[0] == '2':
-                    sitedirs.append(os.path.join(prefix, "lib",
-                                                 "python" + sys.version[:3],
-                                                 "dist-packages"))
-                else:
-                    sitedirs.append(os.path.join(prefix, "lib",
-                                                 "python" + sys.version[0],
-                                                 "dist-packages"))
-                sitedirs.append(os.path.join(prefix, "local/lib",
-                                             "python" + sys.version[:3],
-                                             "dist-packages"))
-                sitedirs.append(os.path.join(prefix, "lib", "dist-python"))
+                # PLD-specific noarch directory:
+                sitedirs.append(os.path.join(prefix, "share",
+                        "python" + sys.version[:3]))
             else:
                 sitedirs = [prefix, os.path.join(prefix, "lib", "site-packages")]
             if sys.platform == 'darwin':
@@ -577,14 +560,9 @@
     elif sys.platform == 'win32':
         paths = [os.path.join(sys.real_prefix, 'Lib'), os.path.join(sys.real_prefix, 'DLLs')]
     else:
-        paths = [os.path.join(sys.real_prefix, 'lib', 'python'+sys.version[:3])]
+        paths = [os.path.join(sys.real_prefix, sys.lib, 'python'+sys.version[:3]),
+                os.path.join(sys.real_prefix, 'share', 'python'+sys.version[:3])]
         hardcoded_relative_dirs = paths[:] # for the special 'darwin' case below
-        lib64_path = os.path.join(sys.real_prefix, 'lib64', 'python'+sys.version[:3])
-        if os.path.exists(lib64_path):
-            if _is_64bit:
-                paths.insert(0, lib64_path)
-            else:
-                paths.append(lib64_path)
         # This is hardcoded in the Python executable, but relative to
         # sys.prefix.  Debian change: we need to add the multiarch triplet
         # here, which is where the real stuff lives.  As per PEP 421, in
@@ -595,7 +573,7 @@
         except AttributeError:
             # This is a non-multiarch aware Python.  Fallback to the old way.
             arch = sys.platform
-        plat_path = os.path.join(sys.real_prefix, 'lib',
+        plat_path = os.path.join(sys.real_prefix, sys.lib,
                                  'python'+sys.version[:3],
                                  'plat-%s' % arch)
         if os.path.exists(plat_path):
